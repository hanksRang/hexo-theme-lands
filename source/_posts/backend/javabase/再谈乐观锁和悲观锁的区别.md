---
title: 再谈乐观锁和悲观锁的区别
date: 2022-05-18 20:20:28
category:
- backend
- javabase

tags: 再谈乐观锁和悲观锁的区别

---

<img style="width: 100%" src='/images/backend/javabase/再谈乐观锁和悲观锁的区别/3.png'/>

### 背景
<p>常常看到或听到很多人这样解释乐观锁和悲观锁：“乐观锁就是每次修改的时候认为没有其他人（线程）在修改数据，悲观锁是每次修改数据的时候都假设有其他线程争夺修改数据的权利”。
其实这句话只阐明了乐观锁适用于低并发，而悲观锁适用于高并发，其他很多关于这两个锁的概念都没有阐明。
</p>

### 基本概念
乐观锁：对数据操作的并发情况持乐观态度，所以每次修改数据的时候加乐观锁（有的人说这里不加锁，而我认为其实不一定要加数据库的锁才算加锁）。
悲观锁：对数据操作的并发情况持悲观态度，每次修改数据的时候都先悲观锁。

<p>从上面的阐述可看出，乐观和悲观都是针对并发量而言的。<b>那是否可以说明并发低的时候就选择乐观锁，并发高就选择悲观锁？答案是不一定。
回答这个问题要从两种锁的实现方式说起。</b>
</p>

### 实现方式

#### 乐观锁
其中一种常用的方式是对行级数据加版本号控制。如表设计：

字段 | 类型 | 解释
---|---|---
id | BIGINT | 主键
money | DOUBLE | 类型
version | INT | 版本号

<p>假设现在要更新该表的第10行数据，id = 10，money = 500.00，version = 1。 A线程读取到version版本号为1，
那A线程现在就持有version=1的锁（这是一把虚拟的锁）。
恰巧，B线程此时也准备修改第10行数据，也读取到version为1，B线程现在也持有version=1的锁。5秒之后，B线程要做money + 500的操作，
于是将version + 1，money + 500更新到数据库，更新前比对版本号，1 = 1，允许更新，于是执行更新得到version=2，money=1000。
6秒之后，A线程要做money + 200的操作，更新前也对比版本号，1 < 2，拒绝更新（拒绝更新后的操作，可根据各自的业务需要实现）。
</p>

<div style="display: flex; ">
<div style="width: 50%; text-align: center; "><b>乐观锁</b></div>
<div style="width: 50%; text-align: center; "><b>悲观锁</b></div>
</div>
<div style="display: flex; ">
<img style="width: 50%; border-right: 1px solid #cccccc; " src='/images/backend/javabase/再谈乐观锁和悲观锁的区别/1.png' />
<img style="width: 49%; " src='/images/backend/javabase/再谈乐观锁和悲观锁的区别/2.png' />
</div>

#### 悲观锁
实现方式：标记方式

字段 | 类型 | 解释
---|---|---
id | BIGINT | 主键
money | DOUBLE | 类型
thread_id | VARCHAR | 线程ID

<p>仍然假设现在也要更新第10行数据，id = 10, money = 500。A线程读取到该行数据的时候，如果thread_id字段为空，
就将如果thread_id字段为空设置为A线程ID，表示已经锁住这条数据，其他数据都不可以对该条数据进行修改操作；否则已经有线程已经上锁，不可再对
该条数据上锁，可以认为“以更新为目的的读取将失败”（这句话的意思是，如果读取的目的不是为了更新，允许读取；读取的目的是为了更新，不允许读取）。
</p>

### 解决了什么问题

<p>加锁的目的是为了解决并发修改的问题。上述场景A、B两个线程同时操作一条数据，无论是乐观锁还是悲观锁，
本质上的目的都是只允许一个修改成功。</p>

#### 不加锁有什么问题
<p>假如A、B两个线程同时读取到第10行数据，且不对该行数据加锁。A线程先将money = 500，更新为500 + 500 = 1000并保存到数据库，
由于此时未对数据上锁，B线程再对money = 500，更新为500 + 200 = 700并保存到数据库。此时出现的问题，显而易见。A线程的更新操作被B
线程的更新操作覆盖了，这就是有名的<b>丢失更新问题</b>，此时也可以称B线程出现了脏读、脏写。
</p>

### 适用场景
通常来说，针对并发高的情况选择悲观锁，并发低的情况选择乐观锁。但是也要根据具体的应用场景来选择，如果现在有一个算法要求先上锁的线程
更新成功，后来的线程必须等待，那就要采用悲观锁的上锁方式。

### 总结
<p>乐观锁和悲观锁，是对两种锁的抽象，各自都包含了很多实现，体现的是设计锁的两种方式。乐观锁，如Java中CAS更新操作的实现。
悲观锁，如synchronized锁的实现。</p>